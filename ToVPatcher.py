import shutil

import utils
import time
import json
import sys
import os

from concurrent.futures import ThreadPoolExecutor

from packer import VesperiaPacker
from patcher import VesperiaPatcher

class VesperiaPatcherApp:
    packer: VesperiaPacker
    patcher: VesperiaPatcher

    patch_data: dict
    targets: list = []

    clean: bool = False
    threads: int

    def __init__(self, patch_data: str, max_threads: int = 4, apply_immediately: bool = False,
                 clean_build: bool = False):
        self.patch_data = json.load(open(patch_data), object_hook=utils.keys_to_int)
        identifier = f"{self.patch_data['player']}-{self.patch_data['created'].split(' ')[0]}-{self.patch_data['seed']}"

        self.packer = VesperiaPacker(identifier, apply_immediately)

        self.patcher = VesperiaPatcher(identifier)

        self.threads = max_threads

        self.clean = clean_build

    def begin(self):
        start: float = time.time()

        print("--- Tales of Vesperia: Definitive Edition Patcher -------------\n"
              f"\tPlayer: {self.patch_data['player']}\n"
              f"\tGeneration Date: {self.patch_data['created']}\n"
              f"\tSeed: {self.patch_data['seed']}\n"
              f"\n\t[-/-] Threads: {self.threads}\n")

        if 'artes' in self.patch_data or 'skills' in self.patch_data:
            self.patch_btl()

        if 'items' in self.patch_data:
            self.patch_items()

        if 'shops' in self.patch_data:
            self.patch_scenario()

        if 'chests' in self.patch_data or 'search' in self.patch_data:
            self.patch_npc()

        self.packer.apply_patch()
        end: float = time.time()

        if self.clean and os.path.isdir(self.packer.build_dir):
            shutil.rmtree(self.packer.build_dir, ignore_errors=True)

        print(f"\n[-/-] Patch Finished\tTime: {end - start:.2f} seconds")
        if self.packer.apply_immediately:
            print("Automatically applied patch to the game directory.")
        else:
            print(f"Patch Output: {self.packer.output_dir}")

    def patch_btl(self):
        self.packer.unpack_btl()

        if 'artes' in self.patch_data:
            print("> Patching Artes...")
            self.packer.extract_artes()
            self.patcher.patch_artes(self.patch_data['artes'])
            self.packer.pack_artes()

        if 'skills' in self.patch_data:
            print("> Patching Skills...")
            self.packer.extract_skills()
            self.patcher.patch_skills(self.patch_data['skills'])
            self.packer.pack_skills()

        self.packer.pack_btl()

    def patch_items(self):
        print("> Patching Items...")
        self.packer.unpack_item()
        self.patcher.patch_items(self.patch_data['items'])
        self.packer.copy_to_output('item')

    def patch_scenario(self):
        self.packer.extract_scenario()

        if 'shops' in self.patch_data:
            print("> Patching Shops...")
            self.packer.decompress_scenario('0')
            self.patcher.patch_shops(self.patch_data['shops'])

        self.packer.pack_scenario()

    def patch_npc(self):
        self.packer.unpack_npc()

        base_dir: str = os.path.join(self.packer.build_dir, "maps")
        if 'chests' in self.patch_data:
            print("> Patching Chests...")

            def _extract_job(room: str, chest_path: str, dec_path: str):
                self.packer.extract_map(room)
                self.packer.decompress_data(chest_path, dec_path)

            def _pack_job(room: str, chest_path: str, dec_path: str):
                self.packer.compress_data(dec_path, chest_path)
                self.packer.pack_map(room)

            with ThreadPoolExecutor(max_workers=self.threads) as executor:
                for area in self.patch_data['chests'].keys():
                    work_dir: str = os.path.join(base_dir, area)
                    chest: str = os.path.join(work_dir, area + ".tlzc.ext", "0004")
                    decomp_path: str = os.path.join(work_dir, "0004")

                    executor.submit(_extract_job, area, chest, decomp_path)

            with ThreadPoolExecutor(max_workers=self.threads) as executor:
                for area, chests in self.patch_data['chests'].items():
                    executor.submit(self.patcher.patch_chests, area, chests)

            with ThreadPoolExecutor(max_workers=self.threads) as executor:
                for area in self.patch_data['chests'].keys():
                    work_dir: str = os.path.join(base_dir, area)
                    dec_data: str = os.path.join(work_dir, "0004.tlzc")
                    chest_data: str = os.path.join(work_dir, area + ".tlzc.ext", "0004")

                    executor.submit(_pack_job, area, chest_data, dec_data)

        if 'search' in self.patch_data:
            print("> Patching Search Points...")
            search_room: str = "FIELD"
            work_dir: str = os.path.join(base_dir, search_room)
            search_path: str = os.path.join(work_dir, f"{search_room}.tlzc.ext", "0005")
            decomp_path: str = os.path.join(work_dir, "0005")

            self.packer.extract_map(search_room)
            self.packer.decompress_data(search_path, decomp_path)

            self.patcher.patch_search_points(decomp_path + ".tlzc", self.patch_data['search'])

            self.packer.compress_data(decomp_path + ".tlzc", search_path)
            self.packer.pack_map(search_room)

        self.packer.copy_to_output('npc')

if __name__ == '__main__':
    patch_file: str = ""
    threads: int = 4
    clean: bool = False
    apply: bool = False

    skip: bool = False
    for i, arg in enumerate(sys.argv[1:]):
        if skip:
            skip = False
            continue

        if arg in ("-h", "--help"):
            print(
                "Usage:\tToVPatcher [OPTIONS] <patch_file>"
                "\n\tPatcher for Tales of Vesperia: Definitive Edition on PC/Steam."
                "\n\n\tPatcher Options:"
                "\n\t\t-t | --threads <amount>\t\tThe number of threads to use. Default: 4." 
                "\n\t\t-c | --clean\t\t\tDelete the used builds subdirectory after patching."
                "\n\t\t-a | --apply-immediately\tImmediately apply the patched files into the game directory, "
                "and move the affected original files to a backup directory (<game_directory>/Data64/.backup)."
                "\n"
                "Management Options"
                "\n\t\t-r | --restore-backup\t\tRestore Backups of the original unmodified files if present "
                "and remove all instances of patched files in the game directory"
            )
            sys.exit(0)
        elif arg in ("-t", "--threads"):
            if len(sys.argv) - 1 - i > 1 and sys.argv[i + 2].isdigit():
                threads = max(1, int(sys.argv[i + 2]))
                skip = True
        elif arg in ("-a", "--apply-immediately"):
            apply = True
        elif arg in ("-c", "--clean"):
            clean = True
        elif arg in ("-r", "--restore-backup"):
            packer = VesperiaPacker()
            packer.restore_backup()
            sys.exit(0)
        elif os.path.isfile(arg) and arg.endswith(".tovdepatch"):
            patch_file = arg

    assert patch_file != "", "No Valid Patch File was provided!"

    app = VesperiaPatcherApp(patch_file, threads, apply, clean)
    app.begin()